using UnityEngine;public class SSCameraMove : MonoBehaviour{    [System.Serializable]    public class CameraMoveData    {        /// <summary>
        /// 最大角度
        /// </summary>        public float MaxAngle = 30f;        /// <summary>        /// 转动速度        /// </summary>        public float RotSpeed = 1f;        /// <summary>        /// 位移速度        /// </summary>        public float PosSpeed = 1f;        bool IsMoveCamera = false;        Transform aimTarget;        Vector3 aimTargetPos = Vector3.zero;        Transform cameraTr;        Transform cameraTrPar;        Transform cameraTrTmp;        internal void SetCameraTr(Transform tr)        {            cameraTr = tr;            if (cameraTrPar == null && cameraTr != null)            {                GameObject obj = new GameObject("CameraParent");                cameraTrPar = obj.transform;                cameraTrPar.position = cameraTr.position;                cameraTrPar.rotation = cameraTr.rotation;                cameraTr.SetParent(cameraTrPar);                obj = new GameObject("cameraTrTmp");                cameraTrTmp = obj.transform;                cameraTrTmp.position = cameraTr.position;                cameraTrTmp.rotation = cameraTr.rotation;                cameraTrTmp.SetParent(cameraTrPar);            }        }        internal void SetAimTarget(Transform tr)        {            aimTarget = tr;        }        internal void SetIsMoveCamera(bool isMove)        {            IsMoveCamera = isMove;            if (IsMoveCamera == false)            {                aimTargetPos = Vector3.zero;            }        }                internal void UpdateLookAtTarget()        {            if (IsMoveCamera == false)            {                MoveCameraToStartPoint();                return;            }            if (aimTarget == null || cameraTr == null)            {                return;            }            //镜头跟踪并锁定弹球，但跟踪、锁定均要有弹簧效果（可调），镜头在上下左右移动时是有一个规定的范围（范围可调）且在镜头锁定            //旋转时四个方向上也有最大角度的限制（最大角度可调）            Vector3 posA = aimTarget.position;            Vector3 posB = cameraTr.position;            Vector3 forward = posA - posB;            //cameraTr.localEulerAngles = new Vector3(0f, 30f, 0f);            if (cameraTrTmp != null)            {                //cameraTrTmp.forward = Vector3.Lerp(cameraTrTmp.forward, forward.normalized, Time.fixedDeltaTime * RotSpeed);
                cameraTrTmp.forward = Vector3.MoveTowards(cameraTrTmp.forward, forward.normalized, Time.fixedDeltaTime * RotSpeed);
                //SSDebug.Log("LocalAngle == " + cameraTrTmp.localEulerAngles);

                float angle = cameraTrTmp.localEulerAngles.y;                if (angle > MaxAngle)
                {
                    if (angle < 180f)
                    {
                        angle = MaxAngle;
                    }
                    else if (angle > 180f)
                    {
                        if (angle < 360f - MaxAngle)
                        {
                            angle = 360f - MaxAngle;
                        }
                    }
                }                //SSDebug.Log("angle == " + angle + ", LocalAngle == " + cameraTrTmp.localEulerAngles);                cameraTr.localEulerAngles = new Vector3(0f, angle, 0f);            }            //cameraTr.forward = Vector3.Lerp(cameraTr.forward, forward, Time.fixedDeltaTime * RotSpeed);                        if (aimTargetPos != Vector3.zero)            {                Vector3 targetMoveForward = posA - aimTargetPos;                Vector3 pos = cameraTr.position + targetMoveForward * Time.fixedDeltaTime * PosSpeed;                cameraTr.position = pos;                aimTargetPos = posA;            }            else            {                aimTargetPos = posA;            }        }        void MoveCameraToStartPoint()        {            if (cameraTrPar == null)            {                return;            }            Vector3 posA = cameraTrPar.position;            //Vector3 forward = cameraTrPar.forward;            //cameraTr.forward = Vector3.Lerp(cameraTr.forward, forward, Time.fixedDeltaTime * RotSpeed);            if (cameraTr.localEulerAngles.magnitude <= Time.fixedDeltaTime * RotSpeed)            {                if (cameraTr.localEulerAngles != Vector3.zero)                {                    cameraTr.localEulerAngles = Vector3.zero;                }            }            else            {                cameraTr.localEulerAngles = Vector3.MoveTowards(cameraTr.localEulerAngles, Vector3.zero, Time.fixedDeltaTime * RotSpeed);            }            Vector3 targetMoveForward = posA - cameraTr.position;            if (targetMoveForward.magnitude <= PosSpeed * Time.fixedDeltaTime)            {                if (cameraTr.position != posA)                {                    cameraTr.position = posA;                }            }            else            {                Vector3 pos = cameraTr.position + targetMoveForward.normalized * Time.fixedDeltaTime * PosSpeed;                cameraTr.position = pos;            }        }    }    public CameraMoveData m_CameraMoveData = new CameraMoveData();    private void Start()    {        Init();        SetCameraTr();    }    void Init()    {        //transform.SetParent(null);    }    void SetCameraTr()    {        if (m_CameraMoveData != null)        {            m_CameraMoveData.SetCameraTr(transform);        }    }    internal void SetAimTarget(Transform tr)    {        if (m_CameraMoveData != null)        {            m_CameraMoveData.SetAimTarget(tr);        }    }    internal void SetIsMoveCamera(bool isMove)    {        if (m_CameraMoveData != null)        {            m_CameraMoveData.SetIsMoveCamera(isMove);        }    }    private void FixedUpdate()    {        if (m_CameraMoveData != null)        {            m_CameraMoveData.UpdateLookAtTarget();        }    }}